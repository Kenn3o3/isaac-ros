{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ROS 2 Humble Documentation","text":"<p>The documentation is based on https://docs.ros.org/en/humble/</p>"},{"location":"#outline","title":"Outline:","text":"<ul> <li>Installation [done]</li> <li>CLI tools [done]<ul> <li>Configuring environment [done]</li> <li>Using <code>turtlesim</code>, <code>ros2</code>, and <code>rpt</code> [done]</li> <li>Understanding nodes []</li> <li>Understanding topics []</li> <li>Understanding services []</li> <li>Understanding parameters []</li> <li>Understanding actions []</li> <li>Using <code>rqt_console</code> to view logs []</li> <li>Launching nodes []</li> <li>Recording and playing back data []</li> </ul> </li> </ul>"},{"location":"#isaac-sim-ros-documentation","title":"Isaac Sim ROS Documentation","text":"<p>The documentation is based on https://docs.omniverse.nvidia.com/isaacsim/latest/installation/install_ros.html</p>"},{"location":"#outline_1","title":"Outline:","text":"<ul> <li>Installation [done]</li> <li>URDF Import: Turtlebot [done]</li> <li>Driving TurtleBot via ROS2 messages [done]</li> <li>ROS 2 Cameras [done]</li> <li>Publishing Camera\u2019s Data []</li> <li>ROS2 Clock []</li> </ul>"},{"location":"Isaac_doc/1_doc/","title":"Installation","text":"<p>Reference</p>"},{"location":"Isaac_doc/1_doc/#install-ros-2","title":"Install ROS 2","text":"<p>Navigate to ROS 2 Installation Documentation to install ROS 2.</p> <p>ROS 2 can be sourced before Isaac Sim is run, allowing Isaac Sim ROS2 bridge to load the ROS2 libraries of your system.</p>"},{"location":"Isaac_doc/1_doc/#enabling-the-ros-bridge-extension","title":"Enabling the ROS Bridge Extension","text":"<p>Create a file named <code>fastdds.xml</code> under <code>~/.ros/</code>:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n\n&lt;license&gt;Copyright (c) 2022-2024, NVIDIA CORPORATION.  All rights reserved.\nNVIDIA CORPORATION and its licensors retain all intellectual property\nand proprietary rights in and to this software, related documentation\nand any modifications thereto.  Any use, reproduction, disclosure or\ndistribution of this software and related documentation without an express\nlicense agreement from NVIDIA CORPORATION is strictly prohibited.&lt;/license&gt;\n\n&lt;profiles xmlns=\"http://www.eprosima.com/XMLSchemas/fastRTPS_Profiles\" &gt;\n    &lt;transport_descriptors&gt;\n        &lt;transport_descriptor&gt;\n            &lt;transport_id&gt;UdpTransport&lt;/transport_id&gt;\n            &lt;type&gt;UDPv4&lt;/type&gt;\n        &lt;/transport_descriptor&gt;\n    &lt;/transport_descriptors&gt;\n\n    &lt;participant profile_name=\"udp_transport_profile\" is_default_profile=\"true\"&gt;\n        &lt;rtps&gt;\n            &lt;userTransports&gt;\n                &lt;transport_id&gt;UdpTransport&lt;/transport_id&gt;\n            &lt;/userTransports&gt;\n            &lt;useBuiltinTransports&gt;false&lt;/useBuiltinTransports&gt;\n        &lt;/rtps&gt;\n    &lt;/participant&gt;\n&lt;/profiles&gt;\n</code></pre> <p>Run <code>export FASTRTPS_DEFAULT_PROFILES_FILE=~/.ros/fastdds.xml</code> in the terminals that will use ROS 2 functions . You must also set it under ~Extra Args\" when launching Isaac Sim from the Nucleus Launcher.</p> <p>Source your ROS 2 installation and workspace before launching Isaac Sim.</p>"},{"location":"Isaac_doc/1_doc/#enable-extension","title":"Enable Extension","text":"<p>Omniverse-launcher &gt; Library &gt; Isaac Sim &gt; Window &gt; Extensions &gt; search <code>ros*_bridge</code> and enable one.</p>"},{"location":"Isaac_doc/1_doc/#next-step","title":"Next Step","text":"<p>To start using Omniverse Isaac Sim with ROS 2, complete the ROS 2 Tutorial series starting with URDF Import: Turtlebot</p>"},{"location":"Isaac_doc/2_doc/","title":"URDF Import: Turtlebot","text":"<p>Reference</p>"},{"location":"Isaac_doc/2_doc/#importing-turtlebot-urdf","title":"Importing TurtleBot URDF","text":"<pre><code>git clone -b humble-devel https://github.com/ROBOTIS-GIT/turtlebot3.git turtlebot3\n</code></pre> <p>The urdf for Turtlebot3 Burger is located in <code>turtlebot3/turtlebot3_description/urdf/turtlebot3_burger.urdf</code></p> <p>Launch Isaac Sim</p> <p>In Content tab inside Isaac Sim:</p> <p>Drag <code>localhost/NVIDIA/Assets/Isaac/4.0/Isaac/Environments/Simple_Room/simple_room.usd</code> to the space</p> <p>Isaac Utils &gt; Workflows &gt; URDF Importer:</p> <ul> <li>Unselect <code>Fix Base Link</code></li> <li>Set Joint Drive Type to <code>Velocity</code></li> <li>In Import File choose the <code>turtlebot3_burger.urdf</code> file</li> <li>Select Output Directory to <code>Desktop</code></li> <li>Click Import</li> </ul>"},{"location":"Isaac_doc/2_doc/#tune-the-robot","title":"Tune the Robot","text":"<p>The URDF importer automatically imports material, physical, and joint properties whenever it is available and have matching categories in Omniverse Isaac Sim. </p> <p>In cases there are no available or matching categories, or if the units are different between the two systems, what gets automatically filled in may not be accurate and changes the robot\u2019s behavior. Here are some properties that can be tuned to correct the robot\u2019s behavior.</p> <p>Frictional Properties</p> <ul> <li>If your robot\u2019s wheels are slipping, try changing the friction coefficients of the wheels and potentially the ground as well following steps 3.4.2 in Add Simple Objects</li> </ul> <p>Physical Properties</p> <ul> <li>If no explicit mass or inertial properties are given, the physics engine will estimate them from the geometry mesh. To update the mass and inertial properties, find the prim that contains the rigid body for the given link (You can verify this by finding \u201cPhysics &gt; Rigid Body\u201d under its property tab). If it already has a \u201cMass\u201d category under its Physics property tab, modify them accordingly. If there isn\u2019t already a \u201cMass\u201d category, you can add it by clicking on the <code>+Add</code> button on top of the Propery tab, and select \u201cPhysics &gt; Mass\u201d.</li> </ul> <p>Joint Properties</p> <ul> <li>If your robot is oscillating at the joint or moving too slow, take a look at the stiffness and damping parameters for the joints. High stiffness makes the joints snap faster and harder to the desire target, and higher damping smoothes but also slows down the joint\u2019s movement to target. For pure position drives, set relatively high stiffness and low damping. For velocity drives, stiffness must be set to zero with a non-zero damping.</li> </ul>"},{"location":"Isaac_doc/2_doc/#next-step","title":"Next Step","text":"<p>Driving TurtleBot via ROS2 messages</p>"},{"location":"Isaac_doc/2_doc/#previous-step","title":"Previous Step","text":"<p>Installation</p>"},{"location":"Isaac_doc/3_doc/","title":"Driving TurtleBot via ROS2 messages","text":"<p>Reference</p>"},{"location":"Isaac_doc/3_doc/#driving-the-robot","title":"Driving the Robot","text":"<p>At the end of URDF Import, the turtle robot has drivable joints, and when given a target position or velocity, it can move the joints to match the targets. However, in most cases, you want to be controlling the vehicle speed and not the individual wheel speed. Therefore we first want to add the appropriate controllers. In the case of Turtlebot3, a wheeled-robot with two wheels, the nodes needed are <code>Differential Controller</code> and <code>Articulation Controller</code>. <code>The Differential Controller</code> node convert vehicle speed to wheel speed, and <code>Articulation Controller</code> node send the commands to the joint drives.</p> <p>Detailed instructions on how to connect these nodes can be found in OmniGraph for a similar robot (NVIDIA Jetbot), so we won\u2019t go into details here.</p>"},{"location":"Isaac_doc/3_doc/#connecting-to-ros2","title":"Connecting to ROS2","text":"<p>As part of our ROS2 bridge, we provide nodes that are subscribers and publisher of specific messages, some utility nodes such as keeping track of simulation time and context ID. You will also find \u201cHelper Nodes\u201d, which are gateways to more complex Omnigraphs that we abstract away from users.</p> <p>To establish a ROS2 bridge for a specific topic, the steps can be generalized to the following: - open an action graph - add the OG nodes relevant to the desired ROS 2 topics - modify any properties as needed - connect the data pipeline</p> <p>The ROS2 publisher nodes are where Omniverse Isaac Sim data gets packaged into ROS message and sent out to the ROS network, and subscriber nodes are where ROS2 messages are received and allocated to the corresponding Omniverse Isaac Sim parameters. So to use them, we simply have to pipe in and out the necessary data, as directed by the properties of each node. If you need to publish or subscribe to messages beyond the ones we provided, checkout Omnigraph: Custom Python Nodes, or Omnigraph: Custom C++ Nodes for ways to integrate custom omnigraph nodes.</p>"},{"location":"Isaac_doc/3_doc/#putting-it-together","title":"Putting it Together","text":""},{"location":"Isaac_doc/3_doc/#building-the-graph","title":"Building the Graph","text":"<ol> <li> <p>Open Visual Scripting: Window &gt; Visual Scripting &gt; Action Graph. An Action Graph window will appear on the bottom, you can dock it wherever that\u2019s convenient.</p> </li> <li> <p>Click on the New Action Graph Icon in middle of the Action Graph Window.</p> </li> <li> <p>Inside the Action Graph window, there is a panel on the left hand side with all the OmniGraph Nodes (or OG nodes). All ROS2 related OG nodes are listed under Isaac Ros2. You can also search for nodes by name. To place node into the graph, simply drag it from the node list into the graph window. If all the ROS related nodes are labeled Ros1 not Ros2, it means you have ROS bridge enabled and not ROS2. Go to Windows &gt; Extensions to disable ROS bridge and enabled ROS2 bridge.</p> </li> <li> <p>Build a graph that matches the one below.</p> </li> </ol> <p></p>"},{"location":"Isaac_doc/3_doc/#graph-explained","title":"Graph Explained","text":"<ol> <li> <p>On Playback Tick Node: Producing a tick when simulation is \u201cPlaying\u201d. Nodes that receives ticks from this node will execute their compute functions every simulation step.</p> </li> <li> <p>ROS2 Context Node: ROS2 uses DDS for its middleware communication. DDS uses Domain ID to allow for different logical networks operate independently even though they share a physical network. ROS 2 nodes on the same domain can freely discover and send messages to each other, while ROS 2 nodes on different domains cannot. ROS2 context node creates a context with a given Domain ID. It is set to 0 by default. If Use Domain ID Env Var is checked, it will import the <code>ROS_DOMAIN_ID</code> from the environment in which you launched the current instance of Isaac Sim.</p> </li> <li> <p>ROS2 Subscribe Twist Node: Subscribing to a Twist message. Specify the Ros Topic\u2019s name <code>/cmd_vel</code> in the topicName field in its Property Tab.     <code>Note the subscriber nodes often have a Exec Out field. This act similar to a tick and will send a signal when a message is received by the subscriber. In this case, we want to only calculate the differential commands when a new twist message arrives. Therefore the Differential Node\u2019s Exec In is ticked by the output of the subscriber node and not by On Playback Tick.</code></p> </li> <li> <p>Scale To/From Stage Unit Node: Convert assets or inputs to stage unit.</p> </li> <li> <p>Break 3-Vector Node: The output of the Twist subscriber node is linear and angular velocities, both 3-dimensional vectors. But the input of the differential controller node only takes a forward velocity and rotation velocity in z-axis, therefore we need to decompose the array and extract the corresponding elements before feeding them into the differential controller node.</p> </li> <li> <p>Differential Controller Node: This node receives desired vehicle speed and calculates the wheel speed of the robot. It needs the wheel radius and distance between the wheels to make that calculation. It can also receive optional speed limit parameters to cap off wheel speed. Type in the property tab the wheel radius, the distance between the wheels, and the maximum linear speed for the vehicle as seen in table below to match the Turtlebot.</p> Field Value Max Linear Speed 0.22 Wheel Distance 0.16 Wheel Radius 0.025 </li> <li> <p>Articulation Controller Node: This node is assigned to a target robot, then takes in the names or the indices of the joints that needs to be moved, and move them by the commands given in either Position Commands, Velocity Commands, or Effort Commands.</p> <ul> <li>Note the Articulation Controller node is ticked by On Playback Tick. So that if no new Twist message arrives, it will continue to execute whatever command it had received before.</li> <li>To assign the Articulation Controller node\u2019s target to be the Turtlebot. In the property tab, click on Add Target and search for the Turtlebot prim in the popup box. Make sure the robot prim you select is also where the Articulation Root API is applied. Sometimes it is the robot\u2019s parent prim. But often times for mobile robots, it is the chassis prim instead. If you used the URDF importer following our previous tutorial, the Articulation Root API can be found on <code>/World/turtlebot3_burger/base_footprint</code>. More about Articulation API can be found in Add Articulation. If the articulation root is set on the base_footprint prim, remove the articulation root property from <code>/World/turtlebot3_burger/base_footprint</code> and add the articulation root property on the main robot prim of <code>/World/turtlebot3_burger</code>.</li> <li>To put the names of the wheel joints in an array format, type in the names of the wheel joints inside each of the Constant Token nodes, and feed the array of the names into the Make Array Node. The names of the joints for the Turtlebot are wheel_left_joint and wheel_right_joint.</li> <li>If you are wondering why not put the names in Constant String node, it\u2019s because OmniGraph does not have string-array data type, therefore if strings needed to be put in an array format to be used by a node, it needs to be token type instead.</li> </ul> </li> </ol>"},{"location":"Isaac_doc/3_doc/#vertify-ros-connections","title":"Vertify ROS connections","text":"<p>Click <code>Play</code>, and then in a separate ROS-sourced terminal, enter <code>ros2 topic list</code>. <code>/cmd_vel</code> should be listed in addition to <code>/parameter_events</code> and <code>/rosout</code></p> <p>on the terminal, enter command: <code>ros2 topic pub /cmd_vel geometry_msgs/Twist \"{'linear': {'x': 0.2, 'y': 0.0, 'z': 0.0}, 'angular': {'x': 0.0, 'y': 0.0, 'z': 0.0}}\"</code> to drive it forward.</p> <p>Enter command <code>ros2 topic pub /cmd_vel geometry_msgs/Twist \"{'linear': {'x': 0.0, 'y': 0.0, 'z': 0.0}, 'angular': {'x': 0.0, 'y': 0.0, 'z': 0.0}}\"</code> to stop it from moving.</p> <p>To make it easier for us to move the Turtlebot around, install the <code>teleop_twist_keyboard</code> by running the following command: <code>sudo apt-get install ros-humble-teleop-twist-keyboard</code></p> <p>Enable driving using the keyboard by running: <code>ros2 run teleop_twist_keyboard teleop_twist_keyboard</code></p> <p>Please see vid/1.webm for demo.</p>"},{"location":"Isaac_doc/3_doc/#next-step","title":"Next Step","text":"<p>ROS2 Cameras</p>"},{"location":"Isaac_doc/3_doc/#previous-step","title":"Previous Step","text":"<p>URDF Import: Turtlebot</p>"},{"location":"Isaac_doc/4_doc/","title":"ROS 2 Cameras","text":"<p>Reference</p>"},{"location":"Isaac_doc/4_doc/#camera-publisher","title":"Camera Publisher","text":""},{"location":"Isaac_doc/4_doc/#setting-up-cameras","title":"Setting Up Cameras","text":"<p>Add two cameras named <code>Camera_1</code> and <code>Camera_2</code>: in Isaac Sim select from tab Create &gt; Camera, rename the cameras byy right-clicking them on the right panel.</p> <p>Build an Action Graph as below:</p> <p></p> <p>Parameters:</p> Node Input Field Value Isaac Create Render Product CameraPrim /World/Camera_1 enabled True ROS2 Camera Helper type rgb topicName rgb frameId turtle"},{"location":"Isaac_doc/4_doc/#graph-explained","title":"Graph Explained","text":"<ol> <li> <p>On Playback Tick Node: Producing a tick when simulation is \u201cPlaying\u201d. Nodes that receives ticks from this node will execute their compute functions every simulation step.</p> </li> <li> <p>ROS2 Context Node: ROS2 uses DDS for its middleware communication. DDS uses Domain ID to allow for different logical networks operate independently even though they share a physical network. ROS 2 nodes on the same domain can freely discover and send messages to each other, while ROS 2 nodes on different domains cannot. ROS2 context node creates a context with a given Domain ID. It is set to 0 by default. If Use Domain ID Env Var is checked, it will import the <code>ROS_DOMAIN_ID</code> from the environment in which you launched the current instance of Isaac Sim.</p> </li> <li> <p>Isaac Create Render Product: Creating a render product prim which acquires the rendered data from the given camera prim and outputs the path to the render product prim. Rendering can be enabled/disabled on command by checking/unchecking the enabled field.</p> </li> <li> <p>Isaac Run One Simulation Frame: This node will make sure the pipeline is only ran once on start.</p> </li> <li> <p>ROS2 Camera Helper: Indicating which type of data to publish, and which rostopic to publish it on.</p> </li> </ol>"},{"location":"Isaac_doc/4_doc/#camera-helper-node","title":"Camera Helper Node","text":"<p>The Camera Helper Node is abstracting a complex postprocessing network from the users. Once you press Play with a Camera Helper Node connected, you may see that in the list of Action Graphs when you click on the icon on the upper left corner of the Action Graph window, a new one appears: <code>/Render/PostProcessing/SDGPipeline</code>. This graph is automatically created by the Camera Helper Node. The pipeline retrieves relevant data from the renderer, process it, and send them to the corresponding ROS publisher. This graph is only created in the session you are running. It will not be saved as part of your asset and will not appear in the Stage tree.</p> <p></p>"},{"location":"Isaac_doc/4_doc/#depth-and-other-perception-ground-truth-data","title":"Depth and other Perception Ground Truth data\uf0c1","text":"<p>In addition to RGB image, the following synthetic sensor and perceptual information also are available for any camera. To see the units used for each synthetic data annotator refer to omni.replicator.</p> <ul> <li>Depth</li> <li>Point Cloud</li> </ul> <p>Before publishing the following bounding box and labels please look at the Isaac Sim Replicator Tutorials to learn about semantically annotating scenes first.</p> <ul> <li>BoundingBox 2D Tight</li> <li>BoundingBox 2D Loose</li> <li>BoundingBox 3D</li> <li>Semantic labels</li> <li>Instance Labels</li> </ul> <p>An example of publishing multiple Rostopics for multiple cameras can be found in the asset <code>Isaac/Samples/ROS2/Scenario/turtlebot_tutorial.usd</code></p>"},{"location":"Isaac_doc/4_doc/#camera-info-helper-node","title":"Camera info Helper Node","text":"<p>The Camera Info Helper publisher node uses the following equations to calculate the K, P, R camera intrinsic matrices.</p> <p>Parameter calculations:</p> <ul> <li>fx = width * focalLength / horizontalAperture</li> <li>fy = height * focalLength / verticalAperture</li> <li>cx = width * 0.5</li> <li>cy = height * 0.5</li> </ul> <p>K Matrix (Matrix of intrinsic parameters)</p> <p>The K matrix is a 3x3 matrix.</p> <ul> <li>K = { fx, 0, cx 0, fy, cy 0, 0, 1 }</li> </ul> <p>P Matrix (Projection Matrix)</p> <p>For stereo cameras the stereo offset of the second camera with respect to the first camera in x and y are denoted as Tx and Ty. These values are computed automatically if two render products are attached to the node.</p> <p>For monocular cameras Tx = Ty = 0.</p> <p>The P matrix is a 3x4 row-major matrix.</p> <p>P = { fx, 0, cx, Tx, 0, fy, cy, Ty, 0, 0, 1, 0 }</p> <p>R Matrix (Rectification Matrix)</p> <p>The R matrix is a rotation matrix applied to align the camera coordinate system with the ideal stereo image plane, ensuring that epipolar lines in both stereo images become parallel. The R matrix is only used for stereo cameras and is set as a 3x3 matrix.</p>"},{"location":"Isaac_doc/4_doc/#graph-shortcut","title":"Graph Shortcut","text":"<p>We provide a menu shortcut to build multiple camera sensor graphs with just a few clicks. Go to Isaac Utils &gt; Common Omnigraphs &gt; ROS2 Camera. (If you don\u2019t see any ROS2 graphs listed, you need to first enable the ROS2 bridge). A popup box below will appear asking for the parameters needed to populate the graphs. You must provide the Graph Path, the Camera Prim, frameId, any Node Namespaces if you have one, and check the boxes for the data you wish to publish. If you wish to add the graphs to an existing graph, check the \u201cAdd to an existing graph?\u201d box. This will append the nodes to the existing graph, and use the existing tick node, context node, and simulation time node if they exist.</p>"},{"location":"Isaac_doc/4_doc/#verify-ros-connection","title":"Verify ROS connection","text":"<p>Use <code>ros2 topic echo /depth</code> to see the raw information that is being passed along</p> <p>In a ROS2-sourced terminal, type in the command <code>rviz2</code> in the GUI, click Add &gt; By topic &gt; Image under <code>/rgb</code> or <code>/depth</code>.</p> <p></p>"},{"location":"Isaac_doc/4_doc/#next-step","title":"Next Step","text":"<p>Checkout Publishing Camera\u2019s Data to learn how to publish camera\u2019s data through Python scripting.</p> <p>ROS2 Clock to learn to setup ROS2 Clock publishers and subscribers with Omniverse Isaac Sim.</p>"},{"location":"Isaac_doc/4_doc/#previous-step","title":"Previous Step","text":"<p>Driving TurtleBot via ROS2 messages</p>"},{"location":"Isaac_doc/5_doc/","title":"Publishing Camera\u2019s Data","text":"<p>Reference</p>"},{"location":"Isaac_doc/5_doc/#setup-vscode-coding-environment","title":"Setup VSCode Coding Environment","text":"<p>In Isaac Sim, click on Window &gt; Extensions and enable <code>omni.isaac.vscode</code> extension.</p> <p>Then click on Window &gt; VS Code to open the Isaac Sim folder in a VS Code application.</p> <p>Source the terminal with:</p> <pre><code>export ISAACSIM_PATH=\"${HOME}/.local/share/ov/pkg/isaac-sim-4.0.0\"\nexport ISAACSIM_PYTHON_EXE=\"${ISAACSIM_PATH}/python.sh\"\n</code></pre> <p>You can also put the above two lines at the end of ~/.bashrc so you would not need to source everytime you open a new terminal.</p>"},{"location":"Isaac_doc/5_doc/#next-step","title":"Next Step","text":"<p>ROS2 Clock</p>"},{"location":"Isaac_doc/5_doc/#previous-step","title":"Previous Step","text":"<p>ROS 2 Cameras</p>"},{"location":"Isaac_doc/6_doc/","title":"ROS2 Clock","text":"<p>Reference</p>"},{"location":"Isaac_doc/6_doc/#next-step","title":"Next Step","text":""},{"location":"Isaac_doc/6_doc/#previous-step","title":"Previous Step","text":"<p>Publishing Camera\u2019s Data</p> <p>ROS 2 Cameras</p>"},{"location":"ROS_doc/1_doc/","title":"Download ROS 2 Humble","text":"<p>navigate to https://docs.ros.org/en/humble/Installation/Ubuntu-Install-Debs.html</p>"},{"location":"ROS_doc/1_doc/#set-locale","title":"Set Locale","text":"<pre><code>locale  # check for UTF-8\n\nsudo apt update &amp;&amp; sudo apt install locales\nsudo locale-gen en_US en_US.UTF-8\nsudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8\nexport LANG=en_US.UTF-8\n\nlocale  # verify settings\n</code></pre>"},{"location":"ROS_doc/1_doc/#setup-sources","title":"Setup Sources","text":"<p>First ensure that the Ubuntu Universe repository is enabled.</p> <pre><code>sudo apt install software-properties-common\nsudo add-apt-repository universe\n</code></pre> <p>Now add the ROS 2 GPG key with apt.</p> <pre><code>sudo apt update &amp;&amp; sudo apt install curl -y\nsudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg\n</code></pre> <p>Then add the repository to your sources list.</p> <pre><code>echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(. /etc/os-release &amp;&amp; echo $UBUNTU_CODENAME) main\" | sudo tee /etc/apt/sources.list.d/ros2.list &gt; /dev/null\n</code></pre>"},{"location":"ROS_doc/1_doc/#install-ros-2-packages","title":"Install ROS 2 packages","text":"<p>Update your apt repository caches after setting up the repositories.</p> <pre><code>sudo apt update\n</code></pre> <p>Desktop Install (Recommended): ROS, RViz, demos, tutorials.</p> <pre><code>sudo apt install ros-humble-desktop\n</code></pre> <p>Development tools: Compilers and other tools to build ROS packages</p> <pre><code>sudo apt install ros-dev-tools\n</code></pre>"},{"location":"ROS_doc/1_doc/#environment-setup","title":"Environment setup","text":""},{"location":"ROS_doc/1_doc/#sourcing-the-setup-script","title":"Sourcing the setup script","text":"<p>Set up your environment by sourcing the following file.</p> <pre><code>source /opt/ros/humble/setup.bash\n</code></pre>"},{"location":"ROS_doc/1_doc/#try-some-examples","title":"Try some examples","text":""},{"location":"ROS_doc/1_doc/#talker-listener","title":"Talker-listener","text":"<p>If you installed <code>ros-humble-desktop</code> above you can try some examples.</p> <p>In one terminal, source the setup file and then run a C++ <code>talker</code>:</p> <pre><code>source /opt/ros/humble/setup.bash\nros2 run demo_nodes_cpp talker\n</code></pre> <p>In another terminal source the setup file and then run a Python <code>listener</code>:</p> <pre><code>source /opt/ros/humble/setup.bash\nros2 run demo_nodes_py listener\n</code></pre> <p>You should see the <code>talker</code> saying that it\u2019s <code>Publishing</code> messages and the <code>listener</code> saying <code>I heard</code> those messages. This verifies both the C++ and Python APIs are working properly. Hooray!</p>"},{"location":"ROS_doc/1_doc/#next-step","title":"Next Step","text":"<p>Please navigate to CLI Tools Document</p>"},{"location":"ROS_doc/2_doc/","title":"CLI Tools Document","text":"<p>Reference</p>"},{"location":"ROS_doc/2_doc/#configuring-environment","title":"Configuring environment","text":"<p>Reference</p>"},{"location":"ROS_doc/2_doc/#source-the-setup-files","title":"Source the setup files","text":"<p>You will need to run this command on every new shell you open to have access to the ROS 2 commands, like so:</p> <pre><code>source /opt/ros/humble/setup.bash\n# or below so you don't need to source every time\necho \"source /opt/ros/humble/setup.bash\" &gt;&gt; ~/.bashrc\n</code></pre>"},{"location":"ROS_doc/2_doc/#check-environment-variables","title":"Check environment variables","text":"<p>Only after source will these environment variables be set</p> <pre><code>printenv | grep -i ROS\n</code></pre> <p>Check that variables like <code>ROS_DISTRO</code> and <code>ROS_VERSION</code> are set.</p> <pre><code>ROS_VERSION=2\nROS_PYTHON_VERSION=3\nROS_DISTRO=humble\n</code></pre>"},{"location":"ROS_doc/2_doc/#the-ros_domain_id-variable","title":"The <code>ROS_DOMAIN_ID</code> variable","text":"<p>For ROS 2 nodes on the same domain to freely communicate. All ROS 2 notes use domain ID 0 by default. To avoid interference between different groups of computers running ROS 2 on the same network, a different domain ID should be set for each group. Choose a domain ID between 0 and 101, inclusive. For example, <code>88</code></p> <pre><code>export ROS_DOMAIN_ID=88\n# Or to maintain this setting between shell sessions, add the command to your shell startup script:\necho \"export ROS_DOMAIN_ID=88\" &gt;&gt; ~/.bashrc\n</code></pre>"},{"location":"ROS_doc/2_doc/#the-ros_localhost_only-variable","title":"The <code>ROS_LOCALHOST_ONLY</code> variable","text":"<p><code>ROS_LOCALHOST_ONLY</code> allows you to limit ROS 2 communication to localhost only, so that your ROS 2 system, and its topics, services, and actions will not be visible to other computers on the local network.</p> <pre><code>export ROS_LOCALHOST_ONLY=1\n# Or to maintain this setting between shell sessions, add the command to your shell startup script:\necho \"export ROS_LOCALHOST_ONLY=1\" &gt;&gt; ~/.bashrc\n</code></pre>"},{"location":"ROS_doc/2_doc/#using-turtlesim-ros2-and-rpt","title":"Using <code>turtlesim</code>, <code>ros2</code>, and <code>rpt</code>","text":"<p>Reference</p>"},{"location":"ROS_doc/2_doc/#concepts","title":"Concepts","text":"<p>Turtlesim is a lightweight simulator for learning ROS 2. It illustrates what ROS 2 does at the most basic level to give you an idea of what you will do with a real robot or a robot simulation later on.</p> <p>The ros2 tool is how the user manages, introspects, and interacts with a ROS system. It supports multiple commands that target different aspects of the system and its operation. One might use it to start a node, set a parameter, listen to a topic, and many more. The ros2 tool is part of the core ROS 2 installation.</p> <p>rqt is a graphical user interface (GUI) tool for ROS 2. Everything done in rqt can be done on the command line, but rqt provides a more user-friendly way to manipulate ROS 2 elements.</p>"},{"location":"ROS_doc/2_doc/#install-turtlesim","title":"Install turtlesim","text":"<pre><code>sudo apt update\nsudo apt install ros-humble-turtlesim\n</code></pre> <p>Check that the package is installed:</p> <pre><code>ros2 pkg executables turtlesim\n</code></pre> <p>Expected output:</p> <pre><code>turtlesim draw_square\nturtlesim mimic\nturtlesim turtle_teleop_key\nturtlesim turtlesim_node\n</code></pre>"},{"location":"ROS_doc/2_doc/#start-turtlesim","title":"Start turtlesim","text":"<pre><code>ros2 run turtlesim turtlesim_node\n</code></pre> <p>What you are expected to see:</p> <pre><code>[INFO] [turtlesim]: Starting turtlesim with node name /turtlesim\n[INFO] [turtlesim]: Spawning turtle [turtle1] at x=[5.544445], y=[5.544445], theta=[0.000000]\n</code></pre>"},{"location":"ROS_doc/2_doc/#use-turtlesim","title":"Use turtlesim","text":"<p>Open another terminal and source ROS 2 again.</p> <pre><code>source /opt/ros/humble/setup.bash\n</code></pre> <p>Run a new node to control the turtle in the first node:</p> <pre><code>ros2 run turtlesim turtle_teleop_key\n</code></pre> <p>You can then use the arrow keys on your keyboard to control the turtle.</p> <p>DO NOT CLOSE THE TERMINALS YET for the next section</p>"},{"location":"ROS_doc/2_doc/#install-rqt","title":"Install rqt","text":"<pre><code>sudo apt update\nsudo apt install '~nros-humble-rqt*'\n</code></pre> <p>run rqt:</p> <pre><code>rqt\n</code></pre>"},{"location":"ROS_doc/2_doc/#use-rqt","title":"Use rqt","text":"<p>select Plugins &gt; Services &gt; Service Caller from the menu bar, you can call different services.</p> <p>Plugins &gt; Services &gt; Service Caller</p>"},{"location":"ROS_doc/2_doc/#try-the-spawn-service","title":"Try the spawn service","text":"<p>Select <code>/clear</code> then Call can clear the line drawn on turtlesim.</p> <p>Select <code>/spawn</code> </p> <p>You can double click between the empty single quotes in the Expression column to give value to name, e.g., <code>Kenny</code></p> <p>You can change <code>x</code> and <code>y</code> to different value e.g. <code>1.0</code> and <code>1.0</code> so that the turtle will spawn in different lcoation.</p> <p>Click Call, the turtle will then spawned in the turtlesim window. </p>"},{"location":"ROS_doc/2_doc/#try-the-set_pen-service","title":"Try the set_pen service","text":"<p>Call service <code>/turtle1/set_pen</code> and set the pen <code>color</code> and <code>width</code> then call again, the pen color will change.</p>"},{"location":"ROS_doc/2_doc/#remapping","title":"Remapping","text":"<p>In order to control <code>Kenny</code>. You can remap the <code>cmd_vel</code> topic. Create a new terminal, source ROS 2, and run:</p> <pre><code>ros2 run turtlesim turtle_teleop_key --ros-args --remap turtle1/cmd_vel:=Kenny/cmd_vel\n</code></pre>"},{"location":"ROS_doc/2_doc/#close-turtlesim","title":"Close turtlesim","text":"<p>Close the <code>turtlesim_node</code> terminal and the <code>turtle_teleop_key</code> terminals.</p>"},{"location":"ROS_doc/2_doc/#understanding-nodes","title":"Understanding nodes","text":"<p>Reference</p>"},{"location":"ROS_doc/2_doc/#understanding-topics","title":"Understanding topics","text":""},{"location":"ROS_doc/2_doc/#understanding-services","title":"Understanding services","text":""},{"location":"ROS_doc/2_doc/#understanding-parameters","title":"Understanding parameters","text":""},{"location":"ROS_doc/2_doc/#understanding-actions","title":"Understanding actions","text":""},{"location":"ROS_doc/2_doc/#using-rqt_console-to-view-logs","title":"Using <code>rqt_console</code> to view logs","text":""},{"location":"ROS_doc/2_doc/#launching-nodes","title":"Launching nodes","text":""},{"location":"ROS_doc/2_doc/#recording-and-playing-back-data","title":"Recording and playing back data","text":""},{"location":"ROS_doc/Cyclone_DDS/","title":"Cyclone DDS Installation","text":""},{"location":"ROS_doc/Cyclone_DDS/#have-rosdep-installed","title":"Have rosdep Installed","text":"<pre><code># if you are using rosdep with ROS\nsudo apt-get install python3-rosdep\n# if you are using rosdep outside of ROS\npip install rosdep\n</code></pre>"},{"location":"ROS_doc/Cyclone_DDS/#rosdep-operation","title":"rosdep operation","text":"<pre><code>sudo rosdep init\nrosdep update\n</code></pre> <p>Finally, we can run <code>rosdep install</code> to install dependencies. Typically, this is run over a workspace with many packages in a single call to install all dependencies. A call for that would appear as the following, if in the root of the workspace with directory <code>src</code> containing source code.</p> <pre><code>rosdep install --from-paths src -y --ignore-src\n</code></pre>"},{"location":"ROS_doc/Cyclone_DDS/#install-packages","title":"Install Packages","text":"<p>Install from ROS 2 apt repository</p> <pre><code>sudo apt install ros-humble-rmw-cyclonedds-cpp\n</code></pre> <p>Switch from other rmw to rmw_cyclonedds by specifying the environment variable.</p> <pre><code>export RMW_IMPLEMENTATION=rmw_cyclonedds_cpp\n</code></pre>"}]}